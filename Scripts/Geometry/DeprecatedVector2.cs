namespace Triangulation
{
    public struct DeprecatedVector2
    {
        //public float X;
        //public float Y;

        //public float SqrLength => X * X + Y * Y;
        //public float Length => MathF.Sqrt(SqrLength);

        //public float this[int index]
        //{
        //    get
        //    {
        //        switch (index)
        //        {
        //            case 0: return X;
        //            case 1: return Y;
        //            default:
        //                throw new IndexOutOfRangeException("Vector2.this[" + index + "]");
        //        }
        //    }
        //    set
        //    {
        //        switch (index)
        //        {
        //            case 0: X = value; break;
        //            case 1: Y = value; break;
        //            default:
        //                throw new IndexOutOfRangeException("Vector2.this[" + index + "]");
        //        }
        //    }
        //}

        //public Vector2(float x, float y)
        //{
        //    this.X = x;
        //    this.Y = y;
        //}


        //public static Vector2 Min(Vector2 v1, Vector2 v2)
        //{
        //    return new Vector2(MathF.Min(v1.X, v2.X), MathF.Min(v1.Y, v2.Y));
        //}

        //public static Vector2 Max(Vector2 v1, Vector2 v2)
        //{
        //    return new Vector2(MathF.Max(v1.X, v2.X), MathF.Max(v1.Y, v2.Y));
        //}

        //public static float SqrDistance(Vector2 v1, Vector2 v2)
        //{
        //    //return (v2 - v1).LengthSquared();
        //    return Vector2.DistanceSquared(v1, v2);
        //}


        //public static float Dot(Vector2 v1, Vector2 v2)
        //{
        //    //return v1.X * v2.X + v1.Y * v2.Y;
        //    return Vector2.Dot(v1, v2);
        //}

        //public static implicit operator Vector2(SerializedVector2 v)
        //{
        //    return new Vector2(v.X, v.Y);
        //}

        //public static implicit operator Vector2(Vector2Int v)
        //{
        //    return new Vector2(v.x, v.y);
        //}

        //public static Vector2 operator /(Vector2 v1, float div)
        //{
        //    return new Vector2(v1.X / div, v1.Y / div);
        //}

        //public static Vector2 operator *(float mlp, Vector2 v)
        //{
        //    return new Vector2(v.X * mlp, v.Y * mlp);
        //}

        //public static Vector2 operator *(Vector2 v, float mlp)
        //{
        //    return mlp * v;
        //}

        //public static Vector2 operator *(Vector2 v1, Vector2 v2)
        //{
        //    return new Vector2(v1.X * v2.X, v1.Y * v2.Y);
        //}

        //public static Vector2 operator +(Vector2 v1, Vector2 v2)
        //{
        //    return new Vector2(v1.X + v2.X, v1.Y + v2.Y);
        //}

        //public static Vector2 operator -(Vector2 v1, Vector2 v2)
        //{
        //    return new Vector2(v1.X - v2.X, v1.Y - v2.Y);
        //}

        //public static Vector2 operator -(Vector2 v1)
        //{
        //    return new Vector2(-v1.X, -v1.Y);
        //}

        //public Vector2 Normalized(out float length)
        //{
        //    length = Length;
        //    return length > Epsilon ? this / length : this;
        //}

        //public Vector2 Normalized()
        //{
        //    return Normalized(out _);
        //}
    }
}
